// Code generated by gitlab.lenvendo.ru/product/grade-factor/services/service-generator  REMOVE THIS STRING ON EDIT OR DO NOT EDIT.
package echo

import (
	"context"
	"errors"

	"github.com/go-kit/kit/log"
	"github.com/go-kit/kit/transport/grpc"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	stdopentracing "github.com/opentracing/opentracing-go"
	googlegrpc "google.golang.org/grpc"
	"google.golang.org/grpc/metadata"

	pb "github.com/arashi5/echo/internal/echoexperimentalechoservicepb"
	"github.com/arashi5/echo/tools/logging"
)

type grpcServer struct {
	createEcho grpctransport.Handler
	getEcho    grpctransport.Handler
}

type ContextGRPCKey struct{}

type GRPCInfo struct{}

// NewGRPCServer makes a set of endpoints available as a gRPC echo Server.
func NewGRPCServer(ctx context.Context, s Service) pb.EchoServiceServer {
	logger := logging.FromContext(ctx)
	logger = log.With(logger, "grpc handler", "echo")
	//tracer := tracing.FromContext(ctx)

	options := []grpctransport.ServerOption{
		// grpctransport.ServerErrorLogger(logger),
		grpctransport.ServerBefore(grpcToContext()),
		//grpctransport.ServerBefore(opentracing.GRPCToContext(tracer, "grpc server", logger)),
		//grpctransport.ServerFinalizer(closeGRPCTracer()),
	}

	return &grpcServer{
		createEcho: grpctransport.NewServer(
			makeCreateEchoEndpoint(s),
			decodeGRPCCreateEchoRequest,
			encodeGRPCCreateEchoResponse,
			options...,
		),
		getEcho: grpctransport.NewServer(
			makeGetEchoEndpoint(s),
			decodeGRPCGetEchoRequest,
			encodeGRPCGetEchoResponse,
			options...,
		),
	}
}

func JoinGRPC(ctx context.Context, s Service) func(*googlegrpc.Server) {
	return func(g *googlegrpc.Server) {
		pb.RegisterEchoServiceServer(g, NewGRPCServer(ctx, s))
	}
}

func grpcToContext() grpc.ServerRequestFunc {
	return func(ctx context.Context, md metadata.MD) context.Context {
		return context.WithValue(ctx, ContextGRPCKey{}, GRPCInfo{})
	}
}
func closeGRPCTracer() grpc.ServerFinalizerFunc {
	return func(ctx context.Context, err error) {
		span := stdopentracing.SpanFromContext(ctx)
		span.Finish()
	}
}

func (s *grpcServer) CreateEcho(ctx context.Context, req *pb.CreateEchoRequest) (*pb.CreateEchoResponse, error) {
	_, rep, err := s.createEcho.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*pb.CreateEchoResponse), nil
}

func (s *grpcServer) GetEcho(ctx context.Context, req *pb.GetEchoListRequest) (*pb.GetEchoListResponse, error) {
	_, rep, err := s.getEcho.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*pb.GetEchoListResponse), nil
}

func decodeGRPCCreateEchoRequest(_ context.Context, request interface{}) (interface{}, error) {
	inReq, ok := request.(*pb.CreateEchoRequest)
	if !ok {
		return nil, errors.New("decodeGRPCCreateEchoRequest wrong request")
	}

	req := PBToCreateEchoRequest(inReq)
	return *req, nil
}

func decodeGRPCGetEchoRequest(_ context.Context, request interface{}) (interface{}, error) {
	inReq, ok := request.(*pb.GetEchoListRequest)
	if !ok {
		return nil, errors.New("decodeGRPCGetEchoRequest wrong request")
	}

	req := PBToGetEchoListRequest(inReq)
	return *req, nil
}

func encodeGRPCCreateEchoResponse(_ context.Context, response interface{}) (interface{}, error) {
	inResp, ok := response.(*CreateEchoResponse)
	if !ok {
		return nil, errors.New("encodeGRPCCreateEchoResponse wrong response")
	}

	return CreateEchoResponseToPB(inResp), nil
}

func encodeGRPCGetEchoResponse(_ context.Context, response interface{}) (interface{}, error) {
	inResp, ok := response.(*GetEchoListResponse)
	if !ok {
		return nil, errors.New("encodeGRPCGetEchoResponse wrong response")
	}

	return GetEchoListResponseToPB(inResp), nil
}

func CreateEchoRequestToPB(d *CreateEchoRequest) *pb.CreateEchoRequest {
	if d == nil {
		return nil
	}

	resp := pb.CreateEchoRequest{
		Data: EchoToPB(d.Data),
	}

	return &resp
}

func PBToCreateEchoRequest(d *pb.CreateEchoRequest) *CreateEchoRequest {
	if d == nil {
		return nil
	}

	resp := CreateEchoRequest{
		Data: PBToEcho(d.Data),
	}

	return &resp
}

func CreateEchoResponseToPB(d *CreateEchoResponse) *pb.CreateEchoResponse {
	if d == nil {
		return nil
	}

	resp := pb.CreateEchoResponse{
		Id: d.Id,
	}

	return &resp
}

func PBToCreateEchoResponse(d *pb.CreateEchoResponse) *CreateEchoResponse {
	if d == nil {
		return nil
	}

	resp := CreateEchoResponse{
		Id: d.Id,
	}

	return &resp
}

func EchoToPB(d *Echo) *pb.Echo {
	if d == nil {
		return nil
	}

	resp := pb.Echo{
		Id:       d.Id,
		Title:    d.Title,
		Reminder: d.Reminder,
	}

	return &resp
}

func PBToEcho(d *pb.Echo) *Echo {
	if d == nil {
		return nil
	}

	resp := Echo{
		Id:       d.Id,
		Title:    d.Title,
		Reminder: d.Reminder,
	}

	return &resp
}

func GetEchoListRequestToPB(d *GetEchoListRequest) *pb.GetEchoListRequest {
	if d == nil {
		return nil
	}

	resp := pb.GetEchoListRequest{}

	return &resp
}

func PBToGetEchoListRequest(d *pb.GetEchoListRequest) *GetEchoListRequest {
	if d == nil {
		return nil
	}

	resp := GetEchoListRequest{}

	return &resp
}

func GetEchoListResponseToPB(d *GetEchoListResponse) *pb.GetEchoListResponse {
	if d == nil {
		return nil
	}

	resp := pb.GetEchoListResponse{}

	for _, v := range *d {
		resp.Echos = append(resp.Echos, EchoToPB(&v))
	}

	return &resp
}

func PBToGetEchoListResponse(d *pb.GetEchoListResponse) *GetEchoListResponse {
	if d == nil {
		return nil
	}

	resp := GetEchoListResponse{}

	for _, v := range d.Echos {
		resp = append(resp, *PBToEcho(v))
	}

	return &resp
}
