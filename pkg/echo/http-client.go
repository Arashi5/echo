// Code generated by gitlab.lenvendo.ru/product/grade-factor/services/service-generator  REMOVE THIS STRING ON EDIT OR DO NOT EDIT.
package echo

import (
	"context"
	"strings"

	"github.com/go-kit/kit/log"
	json "github.com/json-iterator/go"
	stdopentracing "github.com/opentracing/opentracing-go"
	"github.com/pkg/errors"
	"github.com/valyala/fasthttp"
)

type echoHttpClient struct {
	client *fasthttp.HostClient
	logger log.Logger
	tracer stdopentracing.Tracer

	maxRedirectsCount int
}

const (
	httpPrefix        = "http://"
	httpsPrefix       = "https://"
	maxRedirectsCount = 5

	echoMethodPath = "/echo"
)

// NewHTTPClient returns an Service backed by an HTTP server living at the
// remote instance. We expect instance to come from a service discovery system,
// so likely of the form "host:port". We bake-in certain middlewares,
// implementing the client library pattern.
func NewHTTPClient(instance string, tracer stdopentracing.Tracer, logger log.Logger) (Service, error) {
	// HTTPS settings
	useHttps := true
	if strings.HasPrefix(instance, httpPrefix) {
		useHttps = false
	}

	client := fasthttp.HostClient{Addr: cutProtocolPrefix(instance)}
	client.IsTLS = useHttps

	return echoHttpClient{
		client:            &client,
		maxRedirectsCount: maxRedirectsCount,
		logger:            logger,
		tracer:            tracer,
	}, nil
}

func cutProtocolPrefix(host string) string {
	host, _ = strings.CutPrefix(host, httpPrefix)
	host, _ = strings.CutPrefix(host, httpsPrefix)

	return host
}

func (c echoHttpClient) CreateEcho(ctx context.Context, reqDto *CreateEchoRequest) (*CreateEchoResponse, error) {
	url := fasthttp.AcquireURI()
	errParse := url.Parse([]byte(c.client.Addr), []byte(echoMethodPath))
	if errParse != nil {
		return nil, errParse
	}

	httpRequest := fasthttp.AcquireRequest()
	httpRequest.SetURI(url)
	httpRequest.Header.SetMethod(fasthttp.MethodPost)
	fasthttp.ReleaseURI(url)

	encodeErr := encodeHTTPCreateEchoCreateEchoRequest(ctx, httpRequest, reqDto)
	if encodeErr != nil {
		return nil, encodeErr
	}

	response := fasthttp.AcquireResponse()
	reqError := c.client.DoRedirects(httpRequest, response, c.maxRedirectsCount)
	fasthttp.ReleaseRequest(httpRequest)
	if reqError != nil {
		return nil, reqError
	}

	return decodeHTTPCreateEchoCreateEchoRequest(ctx, response)
}

func encodeHTTPCreateEchoCreateEchoRequest(_ context.Context, r *fasthttp.Request, request *CreateEchoRequest) error {
	reqJson, err := json.Marshal(request)
	if err != nil {
		return errors.Wrap(err, "encode request body")
	}

	r.SetBody(reqJson)

	return nil
}

func decodeHTTPCreateEchoCreateEchoRequest(_ context.Context, r *fasthttp.Response) (*CreateEchoResponse, error) {
	if r.StatusCode() != fasthttp.StatusOK {
		return nil, errors.New(string(r.Header.StatusMessage()))
	}

	var response CreateEchoResponse
	if err := json.Unmarshal(r.Body(), &response); err != nil {
		return nil, errors.Wrap(err, "decode request body")
	}

	return &response, nil
}
func (c echoHttpClient) GetEcho(ctx context.Context, reqDto *GetEchoListRequest) (*GetEchoListResponse, error) {
	url := fasthttp.AcquireURI()
	errParse := url.Parse([]byte(c.client.Addr), []byte(echoMethodPath))
	if errParse != nil {
		return nil, errParse
	}

	httpRequest := fasthttp.AcquireRequest()
	httpRequest.SetURI(url)
	httpRequest.Header.SetMethod(fasthttp.MethodPost)
	fasthttp.ReleaseURI(url)

	encodeErr := encodeHTTPGetEchoGetEchoListRequest(ctx, httpRequest, reqDto)
	if encodeErr != nil {
		return nil, encodeErr
	}

	response := fasthttp.AcquireResponse()
	reqError := c.client.DoRedirects(httpRequest, response, c.maxRedirectsCount)
	fasthttp.ReleaseRequest(httpRequest)
	if reqError != nil {
		return nil, reqError
	}

	return decodeHTTPGetEchoGetEchoListRequest(ctx, response)
}

func encodeHTTPGetEchoGetEchoListRequest(_ context.Context, r *fasthttp.Request, request *GetEchoListRequest) error {
	reqJson, err := json.Marshal(request)
	if err != nil {
		return errors.Wrap(err, "encode request body")
	}

	r.SetBody(reqJson)

	return nil
}

func decodeHTTPGetEchoGetEchoListRequest(_ context.Context, r *fasthttp.Response) (*GetEchoListResponse, error) {
	if r.StatusCode() != fasthttp.StatusOK {
		return nil, errors.New(string(r.Header.StatusMessage()))
	}

	var response GetEchoListResponse
	if err := json.Unmarshal(r.Body(), &response); err != nil {
		return nil, errors.Wrap(err, "decode request body")
	}

	return &response, nil
}
