// Code generated by gitlab.lenvendo.ru/product/grade-factor/services/service-generator
package server

import (
	"context"
	"fmt"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/fasthttp/router"
	"github.com/go-kit/kit/log"
	"github.com/go-kit/kit/log/level"
	"github.com/oklog/run"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/valyala/fasthttp"
	"github.com/valyala/fasthttp/fasthttpadaptor"
	"google.golang.org/grpc"

	"github.com/arashi5/echo/configs"
	"github.com/arashi5/echo/tools/limiting"
	"github.com/arashi5/echo/tools/sentry"
)

// Server main struct for experimental-echo-service service
type Server struct {
	cfg     *configs.Config
	logger  log.Logger
	handler fasthttp.RequestHandler
	grpc    *grpc.Server
	group   run.Group
}

// GroupHandler struct for fast http handler
type GroupHandler struct {
	Path    string
	Method  string
	Handler fasthttp.RequestHandler
}

// Option sets up a Server
type Option func(*Server)

func (s *Server) setGroup(group run.Group) {
	s.group = group
}

// Run запускает сервер
func (s *Server) Run() error {
	return s.logger.Log("exit", s.group.Run())
}

// Close closes everything that is open and should be closed after server shutdown
func (s *Server) Close() {

}

// AddHTTP http server start when Server.Run()
func (s *Server) AddHTTP() error {
	addr := fmt.Sprintf(":%d", s.cfg.Server.HTTP.Port)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		return errors.Wrap(err, "cann't add HTTP transport")
	}

	s.group.Add(func() error {
		level.Info(s.logger).Log("component", "HTTP server", "addr", addr, "msg", "listening...")
		if s.cfg.Limiter.Enabled {
			l := limiting.NewLimiter(context.Background(), s.cfg.Limiter.Limit)
			s.handler = l.Middleware(s.handler)
		}

		if s.cfg.Sentry.Enabled {
			s.handler = sentry.Middleware(s.handler)
		}

		httpServer := &fasthttp.Server{
			ReadBufferSize: 1024 * 5,
			Handler:        accessControl(s.handler),
			WriteTimeout:   time.Second * time.Duration(s.cfg.Server.HTTP.TimeoutSec),
		}

		return httpServer.Serve(listener)
	}, func(error) {
		listener.Close()
	})
	return nil
}

// AddGRPC  grpc server start when Server.Run()
func (s *Server) AddGRPC() error {
	addr := fmt.Sprintf(":%d", s.cfg.Server.GRPC.Port)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		return errors.Wrap(err, "cann't add GRPC transport")
	}

	s.group.Add(func() error {
		level.Info(s.logger).Log("component", "GRPC server", "addr", addr, "msg", "listening...")
		return s.grpc.Serve(listener)
	}, func(error) {
		listener.Close()
	})
	return nil
}

// AddMetrics  metrics server start when Server.Run()
func (s *Server) AddMetrics() error {
	if !s.cfg.Metrics.Enabled {
		return nil
	}

	addr := fmt.Sprintf(":%d", s.cfg.Metrics.Port)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		return errors.Wrap(err, "cann't add Metrics")
	}

	s.group.Add(func() error {
		level.Info(s.logger).Log("component", "metrics server", "addr", addr, "msg", "listening...")
		router := router.New()
		router.GET("/metrics", fasthttpadaptor.NewFastHTTPHandler(promhttp.Handler()))
		return fasthttp.Serve(listener, router.Handler)
	}, func(error) {
		listener.Close()
	})

	return nil
}

// AddSignalHandler add listener os signal when Server.Run()
func (s *Server) AddSignalHandler() {
	ch := make(chan struct{})
	s.group.Add(func() error {
		c := make(chan os.Signal, 1)
		signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
		select {
		case sig := <-c:
			return errors.Errorf("received signal %s", sig)
		case <-ch:
			return nil
		}
	}, func(error) {
		close(ch)
	})
}

func accessControl(h fasthttp.RequestHandler) fasthttp.RequestHandler {
	return func(ctx *fasthttp.RequestCtx) {
		ctx.Response.Header.Set("Access-Control-Allow-Origin", "*")
		ctx.Response.Header.Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS, PUT, DELETE, UPDATE, PATCH")
		ctx.Response.Header.Set("Access-Control-Allow-Headers", "Origin, Content-Type, Token, Authorization, Company-UUID, X-Public-Script, X-GF-ApiKey")
		if string(ctx.Method()) == "OPTIONS" {
			return
		}

		h(ctx)
	}
}
